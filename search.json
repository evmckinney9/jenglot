[
  {
    "objectID": "posts/01_rust_wheels/index.html",
    "href": "posts/01_rust_wheels/index.html",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "",
    "text": "The goal of this post is to document the updates I made to my Python project template to support creation of packages with Rust extensions that are installable via pip, without the need for a Rust compiler on the installation target. Utilizing GitHub Actions and cibuildwheel, I automate the creation of wheels across multiple platforms.\nEverything that follows has been implemented in my Python project template."
  },
  {
    "objectID": "posts/01_rust_wheels/index.html#modify-package-structure",
    "href": "posts/01_rust_wheels/index.html#modify-package-structure",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "Modify Package Structure",
    "text": "Modify Package Structure\n\nUpdate pyproject.toml: Add \"setuptools-rust\" to the build system requirements, enabling Rust extension builds within your Python project. For detailed guidance, consult the Setuptools Rust documentation.\n[build-system]\nrequires = [\"setuptools\", \"wheel\", \"setuptools-rust\"]\nbuild-backend = \"setuptools.build_meta\"\nAlso, define Rust extension modules here, as detailed in the RustExtension API documentation.\n[[tool.setuptools-rust.ext-modules]]\ntarget = \"{{project_name}}._accelerate\"\npath = \"crates/Cargo.toml\"\nbinding = \"PyO3\"\nRevise MANIFEST.in: Update this file to include Rust source files in the package, ensuring a comprehensive package build. Guidance on which files to include can be found in this Setuptools documentation.\ninclude pyproject.toml\ninclude crates/Cargo.toml\nrecursive-include crates *.rs\nrecursive-include src *\nDetail crates/Cargo.toml: This file specifies the Rust package’s name, version, and dependencies. PyO3’s inclusion facilitates Python bindings, as outlined in the Cargo manifest format.\n[package]\nname = \"{{project_name}}_accelerate\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\nname = \"{{project_name}}_accelerate\"\ncrate-type = [\"cdylib\"]\npath = \"src/lib.rs\"\n\n[dependencies.pyo3]\nversion = \"0.20.3\"\nfeatures = [\"extension-module\"]"
  },
  {
    "objectID": "posts/01_rust_wheels/index.html#define-the-rust-functions",
    "href": "posts/01_rust_wheels/index.html#define-the-rust-functions",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "Define the Rust Functions",
    "text": "Define the Rust Functions\nThe process of integrating Rust functions into your Python project involves a few key steps:\n\nImplement Rust Functions: Start by defining the Rust functions in crates/src/basic_functions/basic_math.rs. USe PyO3’s #[pyfunction] attribute to ensure these functions are callable from Python.\nFor example, to add and subtract in Rust:\n// crates/src/basic_functions/basic_math.rs\nuse pyo3::prelude::*;\n\n#[pyfunction]\n#[pyo3(text_signature = \"(a, b, /)\")]\npub fn add_in_rust(a: i32, b: i32) -&gt; PyResult&lt;i32&gt; {\n    Ok(a + b)\n}\n\n#[pyfunction]\n#[pyo3(text_signature = \"(a, b, /)\")]\npub fn subtract_in_rust(a: i32, b: i32) -&gt; PyResult&lt;i32&gt; {\n    Ok(a - b)\n}\nPackage Rust Functions into Modules: Next, organize these functions into a module using mod.rs. This step groups your Rust functions logically, making them easier to manage and call from Python.\n// crates/src/basic_functions/mod.rs\npub mod basic_math;\npub mod basic_strings;\n\nuse pyo3::prelude::*;\n\n#[pymodule]\npub fn basic_functions(_py: Python, m: &PyModule) -&gt; PyResult&lt;()&gt; {\n    m.add_wrapped(wrap_pyfunction!(basic_math::add_in_rust))?;\n    m.add_wrapped(wrap_pyfunction!(basic_math::subtract_in_rust))?;\n    m.add_wrapped(wrap_pyfunction!(basic_strings::concat_in_rust))?;\n    Ok(())\n}\nExpose Rust Modules to Python: Finally, use lib.rs to expose the newly created modules to Python. This step ensures that the Rust-written functions are accessible within your Python environment.\n// crates/src/lib.rs\n\nuse pyo3::prelude::*;\nuse pyo3::wrap_pymodule;\n\nmod basic_functions;\n\n#[pymodule]\nfn _accelerate(_py: Python&lt;'_&gt;, m: &PyModule) -&gt; PyResult&lt;()&gt; {\n    m.add_wrapped(wrap_pymodule!(basic_functions::basic_functions))?;\n    Ok(())\n}"
  },
  {
    "objectID": "posts/01_rust_wheels/index.html#testing-the-template",
    "href": "posts/01_rust_wheels/index.html#testing-the-template",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "Testing the Template",
    "text": "Testing the Template\nVerifying the integration involves a straightforward process:\n\nInstantiate and Build: After setting up the template and implementing the Rust functions, create a new repository from the template and clone it to your development environment. I am using Ubuntu in WSL2, with Rust already installed.\n\n\n\nFigure 1: Creating a new repository from the template.\n\n\nBuild and Test: Use the make init command to establish a virtual environment, install the project with all dependencies, and run tests to ensure successful integration.\nevmck@Desktop ~/template_demo\n$ make init\nSuccessful execution and interaction with the package methods can be confirmed in a Jupyter notebook, indicating the Rust functions are callable from Python.\n\n\n\nFigure 2: Successfully calling methods from Jupyter notebook.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nUnsuprisingly, attempting to install the package on an environment without Rust results in a build failure.\nevmck@Evan-Desktop ~/Downloads/template_demo\n$ pip install -e git+https://github.com/evmckinney9/template_demo#egg=template_demo\nThe error encountered:\nError: can't find Rust compiler\n\nERROR: Failed building editable for template_demo\nFailed to build template_demo\nERROR: Could not build wheels for template_demo, which is required to install pyproject.toml-based projects \n(.venv) \nThis issue clarifies the importance of modifying the project’s release strategy to enable distribution to machines without Rust.\n\n\nThis standard project setup leaves us with a clean modular workspace ready for further development. The next steps involve building release workflows to distribute the package across multiple platforms."
  },
  {
    "objectID": "posts/01_rust_wheels/index.html#building-wheels-for-multiple-platforms",
    "href": "posts/01_rust_wheels/index.html#building-wheels-for-multiple-platforms",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "Building Wheels for Multiple Platforms",
    "text": "Building Wheels for Multiple Platforms\nConfigure a GitHub Action workflow with cibuildwheel, which simplifies the process of generating wheels for Linux, macOS (including both Intel and Apple Silicon), and Windows platforms. For more information, refer to the cibuildwheel documentation. The following example will be my starting point:\nname: Build\n\non: [push, pull_request]\n\njobs:\n  build_wheels:\n    name: Build wheels on ${{ matrix.os }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        # macos-13 is an intel runner, macos-14 is apple silicon\n        os: [ubuntu-latest, windows-latest, macos-13, macos-14]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Build wheels\n        uses: pypa/cibuildwheel@v2.17.0\n\n      - uses: actions/upload-artifact@v4\n        with:\n          name: cibw-wheels-${{ matrix.os }}-${{ strategy.job-index }}\n          path: ./wheelhouse/*.whl\nThis configuration will build wheels for all specified platforms in the matrix.os list, with the resulting wheels stored as artifacts. The cibuildwheel action will automatically detect the Python version and build the wheels accordingly.\n\n\n\n\n\n\nNote\n\n\n\nGitHub-hosted runners already have Python and Rust pre-installed, but for Linux builds, an additional step is needed to make the Rust toolchain accessible within the Manylinux container, where the build actually occurs. To ensure the Rust compiler is available for your build, add these environment variables to your workflow:\nenv:\n  CIBW_BEFORE_BUILD_LINUX: curl -sSf https://sh.rustup.rs | sh -s -- -y\n  CIBW_ENVIRONMENT_LINUX: \"PATH=$HOME/.cargo/bin:$PATH\"\n  CIBW_SKIP: \"cp36-* cp37-* cp38-* pp* *-win32 *-musllinux* *_i686\"\nAdditionally, specifying CIBW_SKIP helps circumvent known compatibility issues."
  },
  {
    "objectID": "posts/01_rust_wheels/index.html#building-wheels-for-multiple-python-versions",
    "href": "posts/01_rust_wheels/index.html#building-wheels-for-multiple-python-versions",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "Building Wheels for Multiple Python Versions",
    "text": "Building Wheels for Multiple Python Versions\nPython extension modules are typically tied to the Python version they were compiled against. However, by leveraging the limited Python API (abi3), developers can create extensions that are compatible across multiple Python versions, minimizing the need to build and distribute multiple versions.\n\nPyO3 Documentation: Details how to build and distribute Rust-based Python modules or binaries, covering Python version compatibility and linker arguments.\nSetuptools-Rust Documentation: Describes how to build distributable wheels with setuptools-rust, including how to support multiple Python versions in one binary.\n\n\nBecause setuptools-rust is an extension to setuptools, the standard python -m build command can be used to build distributable wheels.\n\nCorrectly configuring abi3 means cibuildwheel will still work as expected, but with the added benefit of compatibility across multiple Python versions.\n\nEnable abi3 in PyO3: Adjust your crates/Cargo.toml to activate the abi3 feature, ensuring compatibility across Python versions:\n[dependencies.pyo3]\nversion = \"0.20.3\"\nfeatures = [\"extension-module\", \"abi3\"]\nMark Wheels as abi3: Indicate the use of the limited API by configuring your pyproject.toml, which signals that the wheels are compatible with multiple Python versions starting from a specified minimum:\n[tool.distutils.bdist_wheel]\npy_limited_api = \"cp39\"\n\n\n\n\n\n\n\nWarning\n\n\n\nConfiguring wheels for abi3 compatibility via pyproject.toml, as outlined in PyO3/setuptools-rust#399, deviates from standard practices recommended in the official documentation, which suggest using setup.cfg or the DIST_EXTRA_CONFIG environment variable."
  },
  {
    "objectID": "posts/01_rust_wheels/index.html#generate-release-notes-with-commits",
    "href": "posts/01_rust_wheels/index.html#generate-release-notes-with-commits",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "Generate Release Notes with Commits",
    "text": "Generate Release Notes with Commits\nTo complete the release process, we should communicate the changes between versions to users. This is made easier by enforcing Conventional Commits to standardize the structure of commits using a pre-commit hook. To validate commit messages against the convention, I use Git Convention Commits as a pre-commit hook. Additionally, I use Conventional Changelog to generate release notes based on commit messages.\nThis involves adding a step to the workflow to call the conventional-changelog CLI to generate the changelog.\n- name: Generate Changelog\n  run: |\n    npm install -g conventional-changelog-cli\n    conventional-changelog -p conventionalcommits -r 2 | tail -n +3 &gt; CHANGELOG.tmp\n\n\n\n\n\n\nNote\n\n\n\nThe conventional-changelog tool is intended to be run before creating a tag. However, our process triggers it with a tagged commit push. To adapt, we use -r 2, fetching notes up to the second latest tag—capturing the intended release’s notes. We then trim the first two lines to eliminate any unrelated introductory content, ensuring our release notes are succinct and directly related to the changes made.\n\n\nFinally, I use the GH-release action to create a release and attach the generated wheels and changelog.\n- name: Create Release\n  uses: softprops/action-gh-release@v2\n  with:\n    files: ./wheelhouse/**/*.whl\n    body_path: CHANGELOG.tmp\n  env:\n    GITHUB_TOKEN: '${{ secrets.GITHUB_TOKEN }}'\n\nAlternative Tools for Generating Changelogs\n\nGitchangelog: A versatile tool for generating changelogs directly from git commit history, suitable for projects that might not strictly follow the conventional commits format.\nRelease-Please Action: Offered by Google, this action automates release pull requests based on conventional commits. However, it requires the presence of setup.py and setup.cfg in Python repositories, which may not align with all project structures.\nGitHub’s Auto-generated Release Notes: This feature generates release notes based on merged pull requests rather than commits, providing an alternative perspective on the changes between versions."
  },
  {
    "objectID": "posts/01_rust_wheels/index.html#verification",
    "href": "posts/01_rust_wheels/index.html#verification",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "Verification",
    "text": "Verification\nNow that I have implemented all the necessary changes, I can verify the process by following these steps:\n\nCommit and Release: Following the outlined process, any new changes in the project are committed and pushed to the GitHub repository. The GitHub Actions workflow then triggers, building wheels for various platforms and Python versions, culminating in a new release that includes these wheels and auto-generated changelog based on commit messages.\n\n\n\n\nFigure 3: A successful CI pipeline run.\n\n\n\nInstallation: With the release created, users can install the package directly using pip and the URL to the wheel file in the release assets. This step bypasses the need for a Rust compiler on the user’s machine and also ensures compatibility with the Python version specified by the wheel’s abi3 tag.\n\n\n\n\n\n\n\nImportant\n\n\n\nUnlike before, now I’ll pip install directly from the wheel file.\nevmck@Evan-Desktop ~/Downloads/windows_template_demo\n$ pip install https://github.com/evmckinney9/template_demo/releases/download/v0.2.0/template_demo-0.1.0-cp39-abi3-win_amd64.whl\n\n\n\nTesting on Different Environments: Installing the package on a Windows system without Rust installed and on a system with a lower Python version than the one used for package development should proceed without any issues. The successful installation and functionality of Rust methods within Python affirm the package’s cross-platform and cross-version compatibility.\n\n\n\n\nFigure 4: GitHub release showing the changelog and generated wheels.\n\n\nFollowing these steps, template_demo installed and ran without any issues, demonstrating that our workflow for building and distributing Python packages with Rust extensions works as intended."
  },
  {
    "objectID": "posts/01_rust_wheels/index.html#next-steps",
    "href": "posts/01_rust_wheels/index.html#next-steps",
    "title": "Building Python Wheels with Rust Extensions Using GitHub Actions",
    "section": "Next Steps",
    "text": "Next Steps\nSome things I plan to explore in the future include:\n\nDockerize the Environment: Create a Dockerfile to ensure consistent development and testing environments.\nCentralize Python Version Management: Use a single .python-version file to specify the Python version across all environments and configurations.\nAutomate Version Bumping: Implement an automated system for version management that adheres to semantic versioning.\nSimplify Documentation Generation: Choose a documentation generator that integrates well with my existing setup.\nStreamline Workflow Debugging: Explore tools and practices for more efficient debugging of GitHub Actions."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Evan's Blog",
    "section": "",
    "text": "Building Python Wheels with Rust Extensions Using GitHub Actions\n\n\n\n\n\n\ndevops\n\n\npython\n\n\nrust\n\n\ngithub\n\n\n\nThis post covers automating the build process of Python wheels with Rust extensions using GitHub Actions and cibuildwheel, eliminating the need for Rust on the end user’s machine. \n\n\n\n\n\nApr 4, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nConfiguring an LXC container with an external VPN\n\n\n\n\n\n\nproxmox\n\n\nsysops\n\n\n\nThis guide explains how to integrate your LXC container with an external VPN service to enhance the privacy and security of your containerized applications. \n\n\n\n\n\nMar 20, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/00_prox_vpn/index.html",
    "href": "posts/00_prox_vpn/index.html",
    "title": "Configuring an LXC container with an external VPN",
    "section": "",
    "text": "This guide explains how to integrate your LXC container with an external VPN service to enhance the privacy and security of your containerized applications.\nIn this guide, we will configure a qBittorrent LXC container to use WireGuard VPN as its network gateway. I selected AirVPN as the VPN provider due to its support for peer-to-peer (P2P) connections and port forwarding capabilities. However, the concepts and steps outlined here can be adapted to other VPN services and applications according to your needs."
  },
  {
    "objectID": "posts/00_prox_vpn/index.html#wireguard-lxc",
    "href": "posts/00_prox_vpn/index.html#wireguard-lxc",
    "title": "Configuring an LXC container with an external VPN",
    "section": "WireGuard LXC",
    "text": "WireGuard LXC\nFirst, set up WireGuard LXC to integrate your container with the VPN:\n\nInstalling WireGuard LXC: Start by executing the script on your host machine and accept the default settings.\nbash -c \"$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/wireguard.sh)\"\n\n\n\nFigure 1: Initiating WireGuard LXC setup.\n\n\nAfter running the script, install necessary dependencies:\napt install openresolv\napt-get install iptables-persistent\nAcquiring the VPN Configuration:\n\nGo to AirVPN’s WireGuard configuration generator.\n\n\n\n\nFigure 2: Generating AirVPN WireGuard configuration.\n\n\n\nSelect Linux, the WireGuard protocol, and your preferred server location. This will generate a *.conf file with your VPN configuration.\n\n[Interface]\nAddress = 10.178.17.78,fd7d:76ee:e68f:a993:124c:7d1d:869c:84e7\nPrivateKey = [PRIVATE_KEY]\nMTU = 1320\nDNS = 10.128.0.1, fd7d:76ee:e68f:a993::1\n\n[Peer]\nPublicKey = PyLCXAQT8KkM4T+dUsOQfn+Ub3pGxfGlxkIApuig+hk=\nPresharedKey = [PRIVATE_KEY]\nEndpoint = america3.vpn.airdns.org:1637\nAllowedIPs = 0.0.0.0/0,::/0\nPersistentKeepalive = 15\nConfiguring WireGuard with AirVPN:\n\nCheck your current public IP address:\n\ncurl ifconfig.me\n\nUpdate the WireGuard configuration with AirVPN’s details (e.g., wg0.conf, but you can use any name if you are setting up multiple VPNs on the same LXC):\n\nnano /etc/wireguard/wg0.conf\n\nApply the new configuration and restart WireGuard:\n\nwg-quick down wg0\nwg-quick up wg0\nwg show\n\nConfirm the VPN is working by checking your new public IP address:\n\ncurl ifconfig.me\nYou should observe an IP address different from the one initially confirmed, indicating successful VPN integration.\n\n\n\nFigure 3: Verifying WireGuard VPN functionality"
  },
  {
    "objectID": "posts/00_prox_vpn/index.html#qbittorrent-lxc",
    "href": "posts/00_prox_vpn/index.html#qbittorrent-lxc",
    "title": "Configuring an LXC container with an external VPN",
    "section": "qBittorrent LXC",
    "text": "qBittorrent LXC\nNext, set up qBittorrent LXC for secure torrenting through the VPN:\n\nInstalling qBittorrent LXC: Start by executing the script on your host machine and accept the default settings.\nbash -c \"$(wget -qLO - https://github.com/tteck/Proxmox/raw/main/ct/qbittorrent.sh)\"\n\n\n\nFigure 4: Launching the qBittorrent LXC setup.\n\n\nAfter installation, access qBittorrent through your web browser at the provided URL:\nqBittorrent should be reachable by going to the following URL.\n         http://192.168.0.227:8090"
  },
  {
    "objectID": "posts/00_prox_vpn/index.html#network-bridge",
    "href": "posts/00_prox_vpn/index.html#network-bridge",
    "title": "Configuring an LXC container with an external VPN",
    "section": "Network bridge",
    "text": "Network bridge\nCreating a network bridge in Proxmox ensures direct communication between the WireGuard and qBittorrent containers:\n\nCreating a Proxmox Network Bridge:\n\nStart by creating a network bridge in the Proxmox interface, which may vary based on your setup.\n\n\n\n\nFigure 5: Configuring a new network bridge in Proxmox.\n\n\n\nApply the changes to activate the new network bridge.\n\n\n\n\nFigure 6: Finalizing network bridge setup.\n\n\nIntegrating LXCs with the Network Bridge:\n\nAssign the new bridge as a network device for both the WireGuard and qBittorrent LXCs, setting static IP addresses on this new subnet:\n\nWireGuard LXC: 10.10.10.1/24\nqBittorrent LXC: 10.10.10.2/24\n\n\n\n\n\nFigure 7: Assigning the network bridge to LXCs.\n\n\n\nTest the integration by pinging the qBittorrent LXC from the WireGuard LXC.\n\nping 10.10.10.2\n\n\n\nFigure 8: Verifying connectivity between LXCs.\n\n\nGateway Configuration:\n\nWireGuard LXC:\n\nEnable IP forwarding and establish NAT rules:\n\necho \"net.ipv4.ip_forward=1\" | tee -a /etc/sysctl.conf\nsysctl -p\niptables -t nat -A POSTROUTING -o wg0 -j MASQUERADE\n\nSave the iptables configuration to persist across reboots:\n\nnetfilter-persistent save\nqBittorrent LXC:\n\nDefine the WireGuard LXC as the default gateway. Update /etc/network/interfaces with the gateway and DNS settings.\n\nauto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet static\n    address 192.168.0.227 # [Your qBittorrent LXC's static IP]\n    netmask 255.255.255.0\n\nauto eth1\niface eth1 inet static\n    address 10.10.10.2/24\n    netmask 255.255.255.0\n    gateway 10.10.10.1\n    dns-nameservers 1.1.1.1\n    post-up ip route add default via 10.10.10.1 dev eth1\n    post-up ip route del default via 192.168.0.1 dev eth0 || true\n\n\n\n\n\n\nTip\n\n\n\nI recommend using a static IP address for the qBittorrent LXC as DHCP can cause issues with the setup’s persistence across reboots.\n\n\n\n\n\nFigure 9: Default routing through the VPN bridge.\n\n\n\nRestart network services to apply changes.\nConfirm the successful gateway configuration by verifying the IP address is now resolved through the VPN:\n\nping -c 4 google.com  # Test DNS resolution\ncurl ifconfig.me  # Should return the WireGuard IP\n\nIn case of any configuration issues, try bypassing Proxmox’s configuration checks:\n\ntouch /.pve-ignore.resolv.conf\ntouch /etc/network/.pve-ignore.interfaces"
  },
  {
    "objectID": "posts/00_prox_vpn/index.html#qbittorrent-client-configuration",
    "href": "posts/00_prox_vpn/index.html#qbittorrent-client-configuration",
    "title": "Configuring an LXC container with an external VPN",
    "section": "qBittorrent client configuration",
    "text": "qBittorrent client configuration\nFinally, configure the qBittorrent client to ensure secure torrenting through the VPN:\n\nPort Forwarding with AirVPN: Visit AirVPN’s port forwarding section to obtain a port to be forwarded through the VPN. This step is crucial for the qBittorrent client to establish direct connections with peers.\n\n\n\nFigure 10: Acquiring a forwarded port from AirVPN.\n\n\nqBittorrent WebUI:\n\nEnsure the security of your qBittorrent interface by setting a strong password.\n\n\n\n\nFigure 11: Configuring the webgui password for qBittorrent.\n\n\nConfiguring the Listening Port: Access the settings in the qBittorrent WebUI and enter the listening port you received from AirVPN.\n\n\n\nFigure 12: Setting the listening port in qBittorrent.\n\n\nNetwork Interface Binding:\n\nBind qBittorrent to the network interface (eth1) and IP address (10.10.10.2) corresponding to the VPN connection to ensure all traffic goes through the VPN.\n\n\n\n\nFigure 13: Binding qBittorrent to a specific network interface.\n\n\n\n\nRemember to click Save to apply your changes."
  }
]