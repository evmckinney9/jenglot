[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "jenglot",
    "section": "",
    "text": "First Post Test\n\n\n\n\n\n\n\n\n\n\n\n\nEvan McKinney\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/asymptote/03_asymptote.html",
    "href": "posts/asymptote/03_asymptote.html",
    "title": "First Post Test",
    "section": "",
    "text": "Here is some info. Here is some more info.\nWe incldue this because of matplotlib versioning.\n\n# !pip uninstall -y matplotlib && pip install matplotlib==3.7.2\n\n\n# define gateset as any basis with coordinates (x,y, 0)\n# want to find set of 2 gates that give largest disjoint volume\nfrom monodromy.haar import gates_to_haar, expected_cost\nfrom monodromy.render import _plot_coverage_set\nfrom monodromy.coverage import gates_to_coverage, print_coverage_set\nfrom monodromy.haar import gates_to_haar, expected_cost\nfrom monodromy.render import _plot_coverage_set\nfrom monodromy.coverage import gates_to_coverage, print_coverage_set\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nfrom qiskit.circuit.library import iSwapGate\nimport time\n\n\n# g = canonical_gate(*np.array([0.25, 0.25, 0])).full()\n# g = UnitaryGate(g)\n# g.name = \"g\"\n# print(gates_to_haar(g))\n# _ = gates_to_coverage_plot(g)\n\n\ngp = 1 / 4\ng = iSwapGate().power(gp)\nhp = 1 / 5\nh = iSwapGate().power(hp)\ngates = [(g, gp), (h, hp)]\n\n\n\nTest with a single gate compared to a basis with two basis gates.\n\n# print(gates_to_haar(g, h))\ncoverage = gates_to_coverage(*[g], costs=[gp])\nprint(expected_cost(coverage))\n\n0.9598936659817359\n\n\n\n# print(gates_to_haar(g, h))\ncoverage = gates_to_coverage(*[g, h], costs=[gp, hp])\nprint(expected_cost(coverage))\n# print_coverage_set(coverage)\n\n0.8787242759647856\n\n\n\n_plot_coverage_set(coverage)\n\n\n\n\n\n\n\n\n# Hardcoded list of denominators: powers of 2 and primes up to 64\ndenominators = [2, 4, 8, 16, 32, 64]\ndenominators += [\n    3,\n    5,\n    7,\n    11,\n    13,\n    17,\n    19,\n    23,\n    29,\n    31,\n    37,\n    41,\n    43,\n    47,\n    53,\n    59,\n    61,\n]\nfractional_powers = [1 / d for d in denominators]\n\n# Lists to store results and runtimes\nhaar_scores = []\ndecomposition_costs = []\nruntimes = []\n\nfor gp in tqdm(fractional_powers):\n    start_time = time.time()\n\n    # Create the iSWAP gate powered by the fractional power\n    g = iSwapGate().power(gp)\n\n    # Compute the Haar score\n    haar_score = gates_to_haar(g)\n    haar_scores.append(haar_score)\n\n    # Compute the expected decomposition cost\n    coverage = gates_to_coverage(g, costs=[gp])\n    cost = expected_cost(coverage)\n    decomposition_costs.append(cost)\n\n    end_time = time.time()\n    runtime = end_time - start_time\n    runtimes.append(runtime)\n\n  0%|          | 0/23 [00:00&lt;?, ?it/s]100%|██████████| 23/23 [28:07&lt;00:00, 73.37s/it] \n\n\n\n# Plot the results\nfig, ax1 = plt.subplots()\n\n# Twin the axes for decomposition costs\nax2 = ax1.twinx()\n\n# # Twin the axes again for runtimes\n# ax3 = ax1.twinx()\n\n# Move the last Y axis to the right\n# ax3.spines[\"right\"].set_position((\"outward\", 60))\n\n# Plot Haar scores\nax1.plot(denominators, haar_scores, \"g-o\")\nax1.set_xlabel(\"Denominator of Fractional Power\")\nax1.set_ylabel(\"Haar Score\", color=\"g\")\n\n# Plot decomposition costs\nax2.plot(denominators, decomposition_costs, \"b-o\")\nax2.set_ylabel(\"Expected Decomposition Cost\", color=\"b\")\n\n# # Plot runtimes\n# ax3.plot(denominators, runtimes, \"r--o\")\n# ax3.set_ylabel(\"Runtime (seconds)\", color=\"r\")\n\nplt.title(\n    \"iSWAP Fractional Power vs. Haar Score, Decomposition Cost & Runtime\"\n)\nplt.show()\n\n\n\n\n\nimport numpy as np\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\n\n\n# Define the reciprocal function\ndef reciprocal(x, a, b):\n    return a + b / x\n\n\n# Fit the data using curve_fit\nparams, covariance = curve_fit(reciprocal, denominators, decomposition_costs)\n\n# Extract the fitted parameters\na, b = params\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [reciprocal(d, a, b) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, decomposition_costs, \"bo\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Curve\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Expected Decomposition Cost\")\nplt.legend()\nplt.title(\n    \"iSWAP Fractional Power vs. Expected Decomposition Cost with Fitted Asymptote\"\n)\nplt.show()\n\nprint(f\"Asymptote (a): {a}\")\n\n\n\n\nAsymptote (a): 0.8533496992457048\n\n\n\n# Define the linear function\ndef linear(x, m, c):\n    return m * x + c\n\n\n# Fit the data using curve_fit\nparams, _ = curve_fit(linear, denominators, haar_scores)\n\n# Extract the fitted parameters\nm, c = params\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [linear(d, m, c) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, haar_scores, \"g-o\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Line\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Haar Score\")\nplt.legend()\nplt.title(\"iSWAP Fractional Power vs. Haar Score with Fitted Line\")\nplt.show()\n\nprint(f\"Slope (m): {m}\")\nprint(f\"Intercept (c): {c}\")\n\n\n\n\nSlope (m): 0.8543795110777335\nIntercept (c): 0.457798292267894\n\n\n\n# Extract the fitted parameters\na, b = m, c\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [reciprocal(d, a, b) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, decomposition_costs, \"bo\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Curve\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Expected Decomposition Cost\")\nplt.legend()\nplt.title(\n    \"iSWAP Fractional Power vs. Expected Decomposition Cost with Fitted Asymptote\"\n)\nplt.show()"
  },
  {
    "objectID": "posts/asymptote/03_asymptote.html#calculate-asymptotic-haar-score-for-iswap-basis.",
    "href": "posts/asymptote/03_asymptote.html#calculate-asymptotic-haar-score-for-iswap-basis.",
    "title": "First Post Test",
    "section": "",
    "text": "# Hardcoded list of denominators: powers of 2 and primes up to 64\ndenominators = [2, 4, 8, 16, 32, 64]\ndenominators += [\n    3,\n    5,\n    7,\n    11,\n    13,\n    17,\n    19,\n    23,\n    29,\n    31,\n    37,\n    41,\n    43,\n    47,\n    53,\n    59,\n    61,\n]\nfractional_powers = [1 / d for d in denominators]\n\n# Lists to store results and runtimes\nhaar_scores = []\ndecomposition_costs = []\nruntimes = []\n\nfor gp in tqdm(fractional_powers):\n    start_time = time.time()\n\n    # Create the iSWAP gate powered by the fractional power\n    g = iSwapGate().power(gp)\n\n    # Compute the Haar score\n    haar_score = gates_to_haar(g)\n    haar_scores.append(haar_score)\n\n    # Compute the expected decomposition cost\n    coverage = gates_to_coverage(g, costs=[gp])\n    cost = expected_cost(coverage)\n    decomposition_costs.append(cost)\n\n    end_time = time.time()\n    runtime = end_time - start_time\n    runtimes.append(runtime)\n\n  0%|          | 0/23 [00:00&lt;?, ?it/s]100%|██████████| 23/23 [28:07&lt;00:00, 73.37s/it] \n\n\n\n# Plot the results\nfig, ax1 = plt.subplots()\n\n# Twin the axes for decomposition costs\nax2 = ax1.twinx()\n\n# # Twin the axes again for runtimes\n# ax3 = ax1.twinx()\n\n# Move the last Y axis to the right\n# ax3.spines[\"right\"].set_position((\"outward\", 60))\n\n# Plot Haar scores\nax1.plot(denominators, haar_scores, \"g-o\")\nax1.set_xlabel(\"Denominator of Fractional Power\")\nax1.set_ylabel(\"Haar Score\", color=\"g\")\n\n# Plot decomposition costs\nax2.plot(denominators, decomposition_costs, \"b-o\")\nax2.set_ylabel(\"Expected Decomposition Cost\", color=\"b\")\n\n# # Plot runtimes\n# ax3.plot(denominators, runtimes, \"r--o\")\n# ax3.set_ylabel(\"Runtime (seconds)\", color=\"r\")\n\nplt.title(\n    \"iSWAP Fractional Power vs. Haar Score, Decomposition Cost & Runtime\"\n)\nplt.show()\n\n\n\n\n\nimport numpy as np\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\n\n\n# Define the reciprocal function\ndef reciprocal(x, a, b):\n    return a + b / x\n\n\n# Fit the data using curve_fit\nparams, covariance = curve_fit(reciprocal, denominators, decomposition_costs)\n\n# Extract the fitted parameters\na, b = params\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [reciprocal(d, a, b) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, decomposition_costs, \"bo\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Curve\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Expected Decomposition Cost\")\nplt.legend()\nplt.title(\n    \"iSWAP Fractional Power vs. Expected Decomposition Cost with Fitted Asymptote\"\n)\nplt.show()\n\nprint(f\"Asymptote (a): {a}\")\n\n\n\n\nAsymptote (a): 0.8533496992457048\n\n\n\n# Define the linear function\ndef linear(x, m, c):\n    return m * x + c\n\n\n# Fit the data using curve_fit\nparams, _ = curve_fit(linear, denominators, haar_scores)\n\n# Extract the fitted parameters\nm, c = params\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [linear(d, m, c) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, haar_scores, \"g-o\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Line\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Haar Score\")\nplt.legend()\nplt.title(\"iSWAP Fractional Power vs. Haar Score with Fitted Line\")\nplt.show()\n\nprint(f\"Slope (m): {m}\")\nprint(f\"Intercept (c): {c}\")\n\n\n\n\nSlope (m): 0.8543795110777335\nIntercept (c): 0.457798292267894\n\n\n\n# Extract the fitted parameters\na, b = m, c\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [reciprocal(d, a, b) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, decomposition_costs, \"bo\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Curve\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Expected Decomposition Cost\")\nplt.legend()\nplt.title(\n    \"iSWAP Fractional Power vs. Expected Decomposition Cost with Fitted Asymptote\"\n)\nplt.show()"
  }
]