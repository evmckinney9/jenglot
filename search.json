[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Evan's Blog",
    "section": "",
    "text": "Second Post\n\n\nQuantum Volume Experiment\n\n\n\n\njupyter\n\n\nQiskit\n\n\n\n\nThis is the description, using Qiskit noise models something something\n\n\n\n\n\n\nOct 19, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/depth/index.html",
    "href": "posts/depth/index.html",
    "title": "Second Post",
    "section": "",
    "text": "Goal is to create a generic quantum noise model, simulate a circuit and show the relationship between circuit depth and fidelity.\nFidelity is defined using.\n\\[\nF(\\rho_1, \\rho_2) \\!=\\! \\text{Tr}[\\sqrt{\\sqrt{\\rho_1}\\rho_2\\sqrt{\\rho_1}}]^2\n\\]\nApproximate as a function of depth, for an \\(N\\) qubit circuit with duration \\(D_C\\):\n\\[\nF_T \\!=\\! e^{-N  D_C \\left( \\frac{1}{T_1} + \\frac{1}{T_2} \\right)}\n\\]\n\nfrom qiskit.transpiler.coupling import CouplingMap\nimport numpy as np\n\n# Import from Qiskit Aer noise module\n\nfrom mirror_gates.noisy_fidelity import get_noisy_fidelity\nfrom tqdm import tqdm\n\nfrom qiskit.circuit.random import random_circuit\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom qiskit.circuit.library import QFT\nfrom qiskit.transpiler import CouplingMap\nfrom mirror_gates.noisy_fidelity import T1, T2\n\n\nN = 8\n# coupling_map = CouplingMap.from_full(N)\ncoupling_map = CouplingMap.from_line(N)\n\ndata1 = []\n\nfor i in tqdm(range(2, 100, 4)):\n    qc = random_circuit(N, i, max_operands=2, measure=False)\n    fid, duration, transp, expected_fid = get_noisy_fidelity(qc, coupling_map)\n    data1.append((i, duration, fid))  # Added depth (i) here\n\n  0%|          | 0/25 [00:00&lt;?, ?it/s]  4%|▍         | 1/25 [00:00&lt;00:15,  1.52it/s]  8%|▊         | 2/25 [00:01&lt;00:19,  1.18it/s] 12%|█▏        | 3/25 [00:02&lt;00:19,  1.15it/s] 16%|█▌        | 4/25 [00:03&lt;00:18,  1.15it/s] 20%|██        | 5/25 [00:04&lt;00:18,  1.09it/s] 24%|██▍       | 6/25 [00:05&lt;00:18,  1.03it/s] 28%|██▊       | 7/25 [00:06&lt;00:18,  1.02s/it] 32%|███▏      | 8/25 [00:07&lt;00:18,  1.08s/it] 36%|███▌      | 9/25 [00:09&lt;00:18,  1.16s/it] 40%|████      | 10/25 [00:10&lt;00:17,  1.20s/it] 44%|████▍     | 11/25 [00:11&lt;00:17,  1.27s/it] 48%|████▊     | 12/25 [00:13&lt;00:17,  1.32s/it] 52%|█████▏    | 13/25 [00:14&lt;00:16,  1.35s/it] 56%|█████▌    | 14/25 [00:16&lt;00:15,  1.40s/it] 60%|██████    | 15/25 [00:17&lt;00:14,  1.45s/it] 64%|██████▍   | 16/25 [00:19&lt;00:13,  1.53s/it] 68%|██████▊   | 17/25 [00:21&lt;00:13,  1.63s/it] 72%|███████▏  | 18/25 [00:23&lt;00:11,  1.67s/it] 76%|███████▌  | 19/25 [00:25&lt;00:10,  1.75s/it] 80%|████████  | 20/25 [00:27&lt;00:09,  1.85s/it] 84%|████████▍ | 21/25 [00:29&lt;00:07,  1.94s/it] 88%|████████▊ | 22/25 [00:31&lt;00:06,  2.11s/it] 92%|█████████▏| 23/25 [00:33&lt;00:04,  2.12s/it] 96%|█████████▌| 24/25 [00:36&lt;00:02,  2.12s/it]100%|██████████| 25/25 [00:38&lt;00:00,  1.54s/it]\n\n\nExpected fidelity: 9.60821465974009e-17\nExpected fidelity: 6.52779751009869e-10\nExpected fidelity: 1.5537993518317284e-07\nExpected fidelity: 1.487574536904077e-06\nExpected fidelity: 3.291008796328393e-05\nExpected fidelity: 4.646880900392177e-05\nExpected fidelity: 0.00031885528474234146\nExpected fidelity: 0.0009914552912741671\nExpected fidelity: 0.002265137938156348\nExpected fidelity: 0.00474708453201627\nExpected fidelity: 0.005742519985323932\nExpected fidelity: 0.012303325377327416\nExpected fidelity: 0.014502353992713901\nExpected fidelity: 0.01696102593499301\nExpected fidelity: 0.030367935062946428\nExpected fidelity: 0.044957026811720244\nExpected fidelity: 0.04889008093421703\nExpected fidelity: 0.08643001927870636\nExpected fidelity: 0.09467141196821131\nExpected fidelity: 0.14829149077067763\nExpected fidelity: 0.1370878899752673\nExpected fidelity: 0.1723881232610031\nExpected fidelity: 0.16047253150531207\nExpected fidelity: 0.22566044135606483\nExpected fidelity: 0.19601552561410554\n\n\n\n# sort by duration\ndata1 = sorted(data1, key=lambda x: x[1])\ndepths_sorted, durations_sorted, fidelities_sorted = zip(*data1)\n\nfig, ax1 = plt.subplots()\n\n# Plotting the fidelity vs. duration (main line)\nax1.set_xlabel(\"Duration\")\nax1.set_ylabel(\"Fidelity\")\nax1.plot(durations_sorted, fidelities_sorted, label=\"Fidelity\")\n\n# Setting the secondary x-axis for the depth of the random circuit\nax2 = ax1.twiny()\nax2.set_xlabel(\"Depth of Random Circuit\")\nax2.set_xticks(durations_sorted)\nax2.set_xticklabels(depths_sorted)\n\nn_qubits = N\nduration_samples = np.linspace(\n    min(durations_sorted), max(durations_sorted), 500\n)\ndecay_factor = [(1 / T1 + 1 / T2) * duration for duration in duration_samples]\nsingle_qubit_fidelity = [np.exp(-factor) for factor in decay_factor]\ntotal_fidelity = [fidelity**n_qubits for fidelity in single_qubit_fidelity]\nlabel_string = r\"$\\left( e^{(-D/T_1 -D/T_2)} \\right)^{N}$\"\n\nax1.plot(duration_samples, total_fidelity, label=label_string, linestyle=\"--\")\nax1.legend()\n\n\nplt.title(\n    \"Random Circuit (8-qubits) Fidelity vs Duration with Circuit Depth Reference\"\n)\nplt.tight_layout()  # Adjust layout to prevent overlap\nplt.show()\n\n\n\n\n\nN = 8\ncoupling_map = CouplingMap.from_full(N)\ndata2 = []\n\nfor i in tqdm(range(2, N + 1)):\n    qc = QFT(i)\n    fid, duration, transp = get_noisy_fidelity(qc, coupling_map)\n    data2.append((i, duration, fid))\n\n  0%|          | 0/7 [00:00&lt;?, ?it/s]100%|██████████| 7/7 [00:14&lt;00:00,  2.06s/it]\n\n\n\n# sort by duration\ndata2 = sorted(data2, key=lambda x: x[1])\nsizes_sorted, durations_sorted, fidelities_sorted = zip(*data2)\nfig, ax1 = plt.subplots()\n\n# Plotting the fidelity vs. duration (main line)\nax1.set_xlabel(\"Duration\")\nax1.set_ylabel(\"Fidelity\")\nax1.plot(durations_sorted, fidelities_sorted, label=\"Fidelity\")\nax1.tick_params(axis=\"y\")\n\n# Setting the secondary x-axis for the size of QFT\nax2 = ax1.twiny()\nax2.set_xlabel(\"Size of QFT\")\nax2.set_xticks(durations_sorted)\nax2.set_xticklabels(sizes_sorted)\nax2.tick_params(axis=\"x\")\n\n# Adjusting the reference line calculation\nunique_sizes = list(set(sizes_sorted))\nreference_y_total = []\nduration_samples_total = []\n\nfor size in unique_sizes:\n    min_duration = min(\n        [\n            duration\n            for size_curr, duration in zip(sizes_sorted, durations_sorted)\n            if size_curr == size\n        ]\n    )\n    max_duration = max(\n        [\n            duration\n            for size_curr, duration in zip(sizes_sorted, durations_sorted)\n            if size_curr == size\n        ]\n    )\n    duration_samples = np.linspace(min_duration, max_duration, 100)\n    reference_y = [\n        np.exp(-size * duration / (T1 + T2)) for duration in duration_samples\n    ]\n\n    reference_y_total.extend(reference_y)\n    duration_samples_total.extend(duration_samples)\n\nax1.plot(\n    duration_samples_total,\n    reference_y_total,\n    label=\"e^{-nD / (T_1+T_2)}\",\n    linestyle=\"--\",\n)\n\n\nplt.title(\"n-QFT Fidelity vs Duration with QFT Size Reference\")\nplt.tight_layout()  # Adjust layout to prevent overlap\nplt.show()"
  }
]