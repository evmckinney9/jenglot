[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Evan's Blog",
    "section": "",
    "text": "Second Post\n\n\nQuantum Volume Experiment\n\n\n\n\njupyter\n\n\nQiskit\n\n\n\n\nThis is the description, using Qiskit noise models something something\n\n\n\n\n\n\nOct 19, 2023\n\n\n\n\n\n\n  \n\n\n\n\nFirst Post\n\n\nNotebook for debugging Quarto Formatting\n\n\n\n\njupyter\n\n\nQiskit\n\n\n\n\nThis is the description\n\n\n\n\n\n\nOct 18, 2023\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/depth/index.html",
    "href": "posts/depth/index.html",
    "title": "Second Post",
    "section": "",
    "text": "from qiskit.transpiler.coupling import CouplingMap\nimport numpy as np\n\n# Import from Qiskit Aer noise module\n\nfrom mirror_gates.noisy_fidelity import get_noisy_fidelity\nfrom tqdm import tqdm\n\nfrom qiskit.circuit.random import random_circuit\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom qiskit.circuit.library import QFT\nfrom qiskit.transpiler import CouplingMap\nfrom mirror_gates.noisy_fidelity import T1, T2\n\n\nN = 8\n# coupling_map = CouplingMap.from_full(N)\ncoupling_map = CouplingMap.from_line(N)\n\ndata1 = []\n\nfor i in tqdm(range(2, 100, 4)):\n    qc = random_circuit(N, i, max_operands=2, measure=False)\n    fid, duration, transp, expected_fid = get_noisy_fidelity(qc, coupling_map)\n    data1.append((i, duration, fid))  # Added depth (i) here\n\n  0%|          | 0/25 [00:00&lt;?, ?it/s]  4%|▍         | 1/25 [00:00&lt;00:15,  1.52it/s]  8%|▊         | 2/25 [00:01&lt;00:19,  1.18it/s] 12%|█▏        | 3/25 [00:02&lt;00:19,  1.15it/s] 16%|█▌        | 4/25 [00:03&lt;00:18,  1.15it/s] 20%|██        | 5/25 [00:04&lt;00:18,  1.09it/s] 24%|██▍       | 6/25 [00:05&lt;00:18,  1.03it/s] 28%|██▊       | 7/25 [00:06&lt;00:18,  1.02s/it] 32%|███▏      | 8/25 [00:07&lt;00:18,  1.08s/it] 36%|███▌      | 9/25 [00:09&lt;00:18,  1.16s/it] 40%|████      | 10/25 [00:10&lt;00:17,  1.20s/it] 44%|████▍     | 11/25 [00:11&lt;00:17,  1.27s/it] 48%|████▊     | 12/25 [00:13&lt;00:17,  1.32s/it] 52%|█████▏    | 13/25 [00:14&lt;00:16,  1.35s/it] 56%|█████▌    | 14/25 [00:16&lt;00:15,  1.40s/it] 60%|██████    | 15/25 [00:17&lt;00:14,  1.45s/it] 64%|██████▍   | 16/25 [00:19&lt;00:13,  1.53s/it] 68%|██████▊   | 17/25 [00:21&lt;00:13,  1.63s/it] 72%|███████▏  | 18/25 [00:23&lt;00:11,  1.67s/it] 76%|███████▌  | 19/25 [00:25&lt;00:10,  1.75s/it] 80%|████████  | 20/25 [00:27&lt;00:09,  1.85s/it] 84%|████████▍ | 21/25 [00:29&lt;00:07,  1.94s/it] 88%|████████▊ | 22/25 [00:31&lt;00:06,  2.11s/it] 92%|█████████▏| 23/25 [00:33&lt;00:04,  2.12s/it] 96%|█████████▌| 24/25 [00:36&lt;00:02,  2.12s/it]100%|██████████| 25/25 [00:38&lt;00:00,  1.54s/it]\n\n\nExpected fidelity: 9.60821465974009e-17\nExpected fidelity: 6.52779751009869e-10\nExpected fidelity: 1.5537993518317284e-07\nExpected fidelity: 1.487574536904077e-06\nExpected fidelity: 3.291008796328393e-05\nExpected fidelity: 4.646880900392177e-05\nExpected fidelity: 0.00031885528474234146\nExpected fidelity: 0.0009914552912741671\nExpected fidelity: 0.002265137938156348\nExpected fidelity: 0.00474708453201627\nExpected fidelity: 0.005742519985323932\nExpected fidelity: 0.012303325377327416\nExpected fidelity: 0.014502353992713901\nExpected fidelity: 0.01696102593499301\nExpected fidelity: 0.030367935062946428\nExpected fidelity: 0.044957026811720244\nExpected fidelity: 0.04889008093421703\nExpected fidelity: 0.08643001927870636\nExpected fidelity: 0.09467141196821131\nExpected fidelity: 0.14829149077067763\nExpected fidelity: 0.1370878899752673\nExpected fidelity: 0.1723881232610031\nExpected fidelity: 0.16047253150531207\nExpected fidelity: 0.22566044135606483\nExpected fidelity: 0.19601552561410554\n\n\n\n# sort by duration\ndata1 = sorted(data1, key=lambda x: x[1])\ndepths_sorted, durations_sorted, fidelities_sorted = zip(*data1)\n\nfig, ax1 = plt.subplots()\n\n# Plotting the fidelity vs. duration (main line)\nax1.set_xlabel(\"Duration\")\nax1.set_ylabel(\"Fidelity\")\nax1.plot(durations_sorted, fidelities_sorted, label=\"Fidelity\")\n\n# Setting the secondary x-axis for the depth of the random circuit\nax2 = ax1.twiny()\nax2.set_xlabel(\"Depth of Random Circuit\")\nax2.set_xticks(durations_sorted)\nax2.set_xticklabels(depths_sorted)\n\nn_qubits = N\nduration_samples = np.linspace(\n    min(durations_sorted), max(durations_sorted), 500\n)\ndecay_factor = [(1 / T1 + 1 / T2) * duration for duration in duration_samples]\nsingle_qubit_fidelity = [np.exp(-factor) for factor in decay_factor]\ntotal_fidelity = [fidelity**n_qubits for fidelity in single_qubit_fidelity]\nlabel_string = r\"$\\left( e^{(-D/T_1 -D/T_2)} \\right)^{N}$\"\n\nax1.plot(duration_samples, total_fidelity, label=label_string, linestyle=\"--\")\nax1.legend()\n\n\nplt.title(\n    \"Random Circuit (8-qubits) Fidelity vs Duration with Circuit Depth Reference\"\n)\nplt.tight_layout()  # Adjust layout to prevent overlap\nplt.show()\n\n\n\n\n\nN = 8\ncoupling_map = CouplingMap.from_full(N)\ndata2 = []\n\nfor i in tqdm(range(2, N + 1)):\n    qc = QFT(i)\n    fid, duration, transp = get_noisy_fidelity(qc, coupling_map)\n    data2.append((i, duration, fid))\n\n  0%|          | 0/7 [00:00&lt;?, ?it/s]100%|██████████| 7/7 [00:14&lt;00:00,  2.06s/it]\n\n\n\n# sort by duration\ndata2 = sorted(data2, key=lambda x: x[1])\nsizes_sorted, durations_sorted, fidelities_sorted = zip(*data2)\nfig, ax1 = plt.subplots()\n\n# Plotting the fidelity vs. duration (main line)\nax1.set_xlabel(\"Duration\")\nax1.set_ylabel(\"Fidelity\")\nax1.plot(durations_sorted, fidelities_sorted, label=\"Fidelity\")\nax1.tick_params(axis=\"y\")\n\n# Setting the secondary x-axis for the size of QFT\nax2 = ax1.twiny()\nax2.set_xlabel(\"Size of QFT\")\nax2.set_xticks(durations_sorted)\nax2.set_xticklabels(sizes_sorted)\nax2.tick_params(axis=\"x\")\n\n# Adjusting the reference line calculation\nunique_sizes = list(set(sizes_sorted))\nreference_y_total = []\nduration_samples_total = []\n\nfor size in unique_sizes:\n    min_duration = min(\n        [\n            duration\n            for size_curr, duration in zip(sizes_sorted, durations_sorted)\n            if size_curr == size\n        ]\n    )\n    max_duration = max(\n        [\n            duration\n            for size_curr, duration in zip(sizes_sorted, durations_sorted)\n            if size_curr == size\n        ]\n    )\n    duration_samples = np.linspace(min_duration, max_duration, 100)\n    reference_y = [\n        np.exp(-size * duration / (T1 + T2)) for duration in duration_samples\n    ]\n\n    reference_y_total.extend(reference_y)\n    duration_samples_total.extend(duration_samples)\n\nax1.plot(\n    duration_samples_total,\n    reference_y_total,\n    label=\"e^{-nD / (T_1+T_2)}\",\n    linestyle=\"--\",\n)\n\n\nplt.title(\"n-QFT Fidelity vs Duration with QFT Size Reference\")\nplt.tight_layout()  # Adjust layout to prevent overlap\nplt.show()"
  },
  {
    "objectID": "posts/asymptote/index.html",
    "href": "posts/asymptote/index.html",
    "title": "First Post",
    "section": "",
    "text": "Here is some info. Here is some more info.\n\n# !pip uninstall -y matplotlib && pip install matplotlib==3.7.2\n\n\n\n\n\n\n\nWarning\n\n\n\nTemp fix for matplotlib versioning.\n\n\n\n\n\n\n\n\nQSP circuit\n\n\n\n\\[\\begin{align}\nU*\\phi =S(\\phi_0)\\prod*{i=1}^d R(a) S(\\phi*i) = S(\\phi_0)R(a) S(\\phi_1) R(a)\\dots S(\\phi*{d-1}) R(a) S(\\phi_d)\n\\end{align}\\]\n\n\n\n# define gateset as any basis with coordinates (x,y, 0)\n# want to find set of 2 gates that give largest disjoint volume\nfrom monodromy.haar import gates_to_haar, expected_cost\nfrom monodromy.render import _plot_coverage_set\nfrom monodromy.coverage import gates_to_coverage, print_coverage_set\nfrom monodromy.haar import gates_to_haar, expected_cost\nfrom monodromy.render import _plot_coverage_set\nfrom monodromy.coverage import gates_to_coverage, print_coverage_set\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\nfrom qiskit.circuit.library import iSwapGate\nimport time\n\n\n# g = canonical_gate(*np.array([0.25, 0.25, 0])).full()\n# g = UnitaryGate(g)\n# g.name = \"g\"\n# print(gates_to_haar(g))\n# _ = gates_to_coverage_plot(g)\n\n\ngp = 1 / 4\ng = iSwapGate().power(gp)\nhp = 1 / 5\nh = iSwapGate().power(hp)\ngates = [(g, gp), (h, hp)]\n\n\n\nTest with a single gate compared to a basis with two basis gates.\n\n# print(gates_to_haar(g, h))\ncoverage = gates_to_coverage(*[g], costs=[gp])\nprint(expected_cost(coverage))\n\n0.9598936659817359\n\n\n\n# print(gates_to_haar(g, h))\ncoverage = gates_to_coverage(*[g, h], costs=[gp, hp])\nprint(expected_cost(coverage))\n# print_coverage_set(coverage)\n\n0.8787242759647856\n\n\nSee Figure 1 to see the coverage set.\n\n_plot_coverage_set(coverage)\n\n\n\n\nFigure 1: Coverage set for a mixed basis.\n\n\n\n\n\n\n\n\n# Hardcoded list of denominators: powers of 2 and primes up to 64\ndenominators = [2, 4, 8, 16, 32, 64]\ndenominators += [\n    3,\n    5,\n    7,\n    11,\n    13,\n    17,\n    19,\n    23,\n    29,\n    31,\n    37,\n    41,\n    43,\n    47,\n    53,\n    59,\n    61,\n]\nfractional_powers = [1 / d for d in denominators]\n\n# Lists to store results and runtimes\nhaar_scores = []\ndecomposition_costs = []\nruntimes = []\n\nfor gp in tqdm(fractional_powers):\n    start_time = time.time()\n\n    # Create the iSWAP gate powered by the fractional power\n    g = iSwapGate().power(gp)\n\n    # Compute the Haar score\n    haar_score = gates_to_haar(g)\n    haar_scores.append(haar_score)\n\n    # Compute the expected decomposition cost\n    coverage = gates_to_coverage(g, costs=[gp])\n    cost = expected_cost(coverage)\n    decomposition_costs.append(cost)\n\n    end_time = time.time()\n    runtime = end_time - start_time\n    runtimes.append(runtime)\n\n  0%|          | 0/23 [00:00&lt;?, ?it/s]100%|██████████| 23/23 [28:07&lt;00:00, 73.37s/it] \n\n\n\n# Plot the results\nfig, ax1 = plt.subplots()\n\n# Twin the axes for decomposition costs\nax2 = ax1.twinx()\n\n# # Twin the axes again for runtimes\n# ax3 = ax1.twinx()\n\n# Move the last Y axis to the right\n# ax3.spines[\"right\"].set_position((\"outward\", 60))\n\n# Plot Haar scores\nax1.plot(denominators, haar_scores, \"g-o\")\nax1.set_xlabel(\"Denominator of Fractional Power\")\nax1.set_ylabel(\"Haar Score\", color=\"g\")\n\n# Plot decomposition costs\nax2.plot(denominators, decomposition_costs, \"b-o\")\nax2.set_ylabel(\"Expected Decomposition Cost\", color=\"b\")\n\n# # Plot runtimes\n# ax3.plot(denominators, runtimes, \"r--o\")\n# ax3.set_ylabel(\"Runtime (seconds)\", color=\"r\")\n\nplt.title(\n    \"iSWAP Fractional Power vs. Haar Score, Decomposition Cost & Runtime\"\n)\nplt.show()\n\n\n\n\n\nimport numpy as np\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\n\n\n# Define the reciprocal function\ndef reciprocal(x, a, b):\n    return a + b / x\n\n\n# Fit the data using curve_fit\nparams, covariance = curve_fit(reciprocal, denominators, decomposition_costs)\n\n# Extract the fitted parameters\na, b = params\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [reciprocal(d, a, b) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, decomposition_costs, \"bo\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Curve\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Expected Decomposition Cost\")\nplt.legend()\nplt.title(\n    \"iSWAP Fractional Power vs. Expected Decomposition Cost with Fitted Asymptote\"\n)\nplt.show()\n\nprint(f\"Asymptote (a): {a}\")\n\n\n\n\nAsymptote (a): 0.8533496992457048\n\n\n\n# Define the linear function\ndef linear(x, m, c):\n    return m * x + c\n\n\n# Fit the data using curve_fit\nparams, _ = curve_fit(linear, denominators, haar_scores)\n\n# Extract the fitted parameters\nm, c = params\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [linear(d, m, c) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, haar_scores, \"g-o\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Line\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Haar Score\")\nplt.legend()\nplt.title(\"iSWAP Fractional Power vs. Haar Score with Fitted Line\")\nplt.show()\n\nprint(f\"Slope (m): {m}\")\nprint(f\"Intercept (c): {c}\")\n\n\n\n\nSlope (m): 0.8543795110777335\nIntercept (c): 0.457798292267894\n\n\n\n# Extract the fitted parameters\na, b = m, c\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [reciprocal(d, a, b) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, decomposition_costs, \"bo\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Curve\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Expected Decomposition Cost\")\nplt.legend()\nplt.title(\n    \"iSWAP Fractional Power vs. Expected Decomposition Cost with Fitted Asymptote\"\n)\nplt.show()"
  },
  {
    "objectID": "posts/asymptote/index.html#calculate-asymptotic-haar-score-for-iswap-basis.",
    "href": "posts/asymptote/index.html#calculate-asymptotic-haar-score-for-iswap-basis.",
    "title": "First Post",
    "section": "",
    "text": "# Hardcoded list of denominators: powers of 2 and primes up to 64\ndenominators = [2, 4, 8, 16, 32, 64]\ndenominators += [\n    3,\n    5,\n    7,\n    11,\n    13,\n    17,\n    19,\n    23,\n    29,\n    31,\n    37,\n    41,\n    43,\n    47,\n    53,\n    59,\n    61,\n]\nfractional_powers = [1 / d for d in denominators]\n\n# Lists to store results and runtimes\nhaar_scores = []\ndecomposition_costs = []\nruntimes = []\n\nfor gp in tqdm(fractional_powers):\n    start_time = time.time()\n\n    # Create the iSWAP gate powered by the fractional power\n    g = iSwapGate().power(gp)\n\n    # Compute the Haar score\n    haar_score = gates_to_haar(g)\n    haar_scores.append(haar_score)\n\n    # Compute the expected decomposition cost\n    coverage = gates_to_coverage(g, costs=[gp])\n    cost = expected_cost(coverage)\n    decomposition_costs.append(cost)\n\n    end_time = time.time()\n    runtime = end_time - start_time\n    runtimes.append(runtime)\n\n  0%|          | 0/23 [00:00&lt;?, ?it/s]100%|██████████| 23/23 [28:07&lt;00:00, 73.37s/it] \n\n\n\n# Plot the results\nfig, ax1 = plt.subplots()\n\n# Twin the axes for decomposition costs\nax2 = ax1.twinx()\n\n# # Twin the axes again for runtimes\n# ax3 = ax1.twinx()\n\n# Move the last Y axis to the right\n# ax3.spines[\"right\"].set_position((\"outward\", 60))\n\n# Plot Haar scores\nax1.plot(denominators, haar_scores, \"g-o\")\nax1.set_xlabel(\"Denominator of Fractional Power\")\nax1.set_ylabel(\"Haar Score\", color=\"g\")\n\n# Plot decomposition costs\nax2.plot(denominators, decomposition_costs, \"b-o\")\nax2.set_ylabel(\"Expected Decomposition Cost\", color=\"b\")\n\n# # Plot runtimes\n# ax3.plot(denominators, runtimes, \"r--o\")\n# ax3.set_ylabel(\"Runtime (seconds)\", color=\"r\")\n\nplt.title(\n    \"iSWAP Fractional Power vs. Haar Score, Decomposition Cost & Runtime\"\n)\nplt.show()\n\n\n\n\n\nimport numpy as np\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\n\n\n# Define the reciprocal function\ndef reciprocal(x, a, b):\n    return a + b / x\n\n\n# Fit the data using curve_fit\nparams, covariance = curve_fit(reciprocal, denominators, decomposition_costs)\n\n# Extract the fitted parameters\na, b = params\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [reciprocal(d, a, b) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, decomposition_costs, \"bo\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Curve\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Expected Decomposition Cost\")\nplt.legend()\nplt.title(\n    \"iSWAP Fractional Power vs. Expected Decomposition Cost with Fitted Asymptote\"\n)\nplt.show()\n\nprint(f\"Asymptote (a): {a}\")\n\n\n\n\nAsymptote (a): 0.8533496992457048\n\n\n\n# Define the linear function\ndef linear(x, m, c):\n    return m * x + c\n\n\n# Fit the data using curve_fit\nparams, _ = curve_fit(linear, denominators, haar_scores)\n\n# Extract the fitted parameters\nm, c = params\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [linear(d, m, c) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, haar_scores, \"g-o\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Line\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Haar Score\")\nplt.legend()\nplt.title(\"iSWAP Fractional Power vs. Haar Score with Fitted Line\")\nplt.show()\n\nprint(f\"Slope (m): {m}\")\nprint(f\"Intercept (c): {c}\")\n\n\n\n\nSlope (m): 0.8543795110777335\nIntercept (c): 0.457798292267894\n\n\n\n# Extract the fitted parameters\na, b = m, c\n\n# Generate the fitted curve using the extracted parameters\nfitted_curve = [reciprocal(d, a, b) for d in denominators]\n\n# Plot the original data and the fitted curve\nplt.plot(denominators, decomposition_costs, \"bo\", label=\"Original Data\")\nplt.plot(denominators, fitted_curve, \"r-\", label=\"Fitted Curve\")\nplt.xlabel(\"Denominator of Fractional Power\")\nplt.ylabel(\"Expected Decomposition Cost\")\nplt.legend()\nplt.title(\n    \"iSWAP Fractional Power vs. Expected Decomposition Cost with Fitted Asymptote\"\n)\nplt.show()"
  }
]